#!/bin/sh

# Convert a Haskell package for use by Hugs

usage="$0 <source-directory> <target-directory>"

# The source directory is assumed to be the root of a package hierarchy,
# i.e. A/B/C.hs contains the module A.B.C
#
# The file hugs/exclude (if present in the source directory) contains
# a list of modules that aren't to be used with Hugs, one per line,
# possibly with commentary on the rest of the line.
#
# Several packages may be put into the same target directory, as long as
# they don't overlap (which they aren't supposed to).

cpp_flags='-D__HUGS__'

cc=${CC-gcc}
: ${cpp=gcc -P -E -traditional -xc}
: ${hsc2hs=hsc2hs}
: ${greencard=green-card}
: ${ffihugs=`dirname $0`/../ffihugs}

# platform sensitive settings
case `uname -a` in
*CYGWIN*) # For Win32
	CALLCONV=stdcall ;;
*)	CALLCONV=ccall ;;
esac

case $# in
2)	;;
*)	echo "usage: $usage" >&2
	exit 1 ;;
esac

source_dir=$1
target_dir=$2

if [ ! -d $source_dir ]; then
	echo "Can't find directory '$1'" >&2
	exit 1
fi

includes="-I. -I.. -I$source_dir/include"
tmpdir=/tmp/cvt.$$

[ -d $tmpdir ] && rm -r $tmpdir

extract_includes() {
	sed -n 's/^{-# OPTIONS -\(#include .*\) #-}/\1/p' $*
}

hack_foreign() {
	sed '	/^foreign[	 ]/ {
			s/"\([^ ]*\)"/"'"$1"' \1"/
			s/CALLCONV/'"$CALLCONV"'/
		}'
}

# Determine the list of modules to be converted

module_list=/tmp/cvs.$$.1
tmp=/tmp/cvs.$$.2

trap "rm -f $module_list $tmp; exit 0" 0 1 2 3 15

(
	cd $source_dir
	find . \( -name '[a-z]*' -o -name GHC -o -name NHC \) -prune -o \
		\( -name \*.hs -o -name \*.lhs -o -name \*.hsc \
			-o -name \*.y -o -name \*.ly -o -name \*.gc \) -print |
		sed '	s:^\./::
			s/\..*//' |
		sort -u >$tmp

	if [ -f hugs/exclude ]; then
		sed '	/^[	]*#/ d
			/^[ 	]*$/ d
			s/[ 	].*//
			s:\.:/:g' hugs/exclude |
		sort -u | comm -13 - $tmp >$module_list
	else
		mv $tmp $module_list
	fi
)

# Pass 1: preprocess modules

while read modname
do	echo "Converting $modname"

	stem=$source_dir/$modname
	target_stem=$target_dir/$modname
	dstdir=`dirname $target_stem`
	basename=`basename $stem`

	mkdir -p $dstdir

	# Prefer *_hsc_make.c to *.hsc, and *.hs to *.[l]y,
	# so that if these are present we don't need hsc2hs and happy.
	# (But don't take .hs if .hsc is present.)

	if [ -f ${stem}_hsc_make.c ]; then
		# with hacks to extract the -#include directives and
		# to substitute CALLCONV in Network.Socket (ugh)
		header="${basename}_aux.h"

		# don't run hsc2hs if its output is already present
		hsc_make="${target_stem}_hsc_make"
		$cc $cpp_flags $includes -o "$hsc_make" "${stem}_hsc_make.c"
		$hsc_make | hack_foreign $header >$target_stem.hs
		rm "$hsc_make"

		extract_includes $target_stem.hs >"$dstdir/$header"
	elif [ -f $stem.hsc ]; then
		# with hacks to extract the -#include directives and
		# to substitute CALLCONV in Network.Socket (ugh)
		header="${basename}_aux.h"

		copy="$target_stem.hsc"
		hack_foreign $header <$stem.hsc >$copy
		$hsc2hs --cc="$cc" $cpp_flags $includes "$copy"
		rm "$copy"

		extract_includes $target_stem.hs >"$dstdir/$header"
	elif [ -f $stem.gc ]; then
		abs_src_dir=`cd $source_dir; pwd`
		(
			cd $target_dir
			$greencard -t ffi -i $abs_src_dir $modname.gc
		)
	elif [ -f $stem.hs ]; then
		$cpp $cpp_flags $includes $stem.hs | cat -s >$target_stem.hs
	elif [ -f $stem.lhs ]; then
		$cpp $cpp_flags $includes $stem.lhs | cat -s >$target_stem.lhs
	elif [ -f $stem.y ]; then
		mkdir $tmpdir
		cp $stem.y $tmpdir
		(
			cd $tmpdir
			happy $basename.y
		)
		$cpp $cpp_flags $tmpdir/$basename.hs | cat -s >$target_stem.hs
		rm -r $tmpdir
	elif [ -f $stem.ly ]; then
		mkdir $tmpdir
		cp $stem.ly $tmpdir
		(
			cd $tmpdir
			happy $basename.ly
		)
		$cpp $cpp_flags $tmpdir/$basename.hs | cat -s >$target_stem.hs
		rm -r $tmpdir
	else
		echo "$0: don't know how to handle $stem" >&2
	fi
done <$module_list

# Pass 2: compile FFI modules (or generate a script to do so)

script=`dirname $0`/BuildFFI

# kludge to add libraries
lib_flags=
case $source_dir in
*/X11)	lib_flags='-L/usr/X11R6/lib -lX11' ;;
*/network)
	case `uname -a` in
	*CYGWIN*) lib_flags=wsock32.lib ;;
	esac ;;
esac

while read modname
do
	stem=$target_dir/$modname
	dstdir=`dirname $stem`
	basename=`basename $stem`
	if [ -f $stem.lhs ]
	then	filename=$stem.lhs
	else	filename=$stem.hs
	fi

	# Crude test for foreign declarations.
	# Running ffihugs on a few extras does no harm.

	if grep '^>*[ 	]*foreign[ 	][ 	]*[ei][mx]port' $filename >/dev/null
	then
		cmd="$ffihugs +G -98 -P$target_dir:"
		for flag in -I$dstdir $includes
		do	cmd="$cmd +L$flag"
		done
		for file in ${stem}_stub_ffi.c ${stem}_hsc.c
		do	if [ -f $file ]
			then	cmd="$cmd +L$file"
			fi
		done
		for file in `sed -n 's/{-# CBITS \(.*\) #-}/\1/p' $filename`
		do	cmd="$cmd +L$source_dir/cbits/$file"
		done
		cmd="$cmd `echo $modname | tr / .`"
		for flag in $lib_flags
		do	cmd="$cmd +L$flag"
		done

		echo "echo 'Compiling $filename'" >>$script
		echo $cmd >>$script
	fi
done <$module_list
