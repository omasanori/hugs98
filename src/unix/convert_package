#!/bin/sh

# Convert a Haskell package for use by Hugs
#
# The source directory is assumed to be the root of a package hierarchy,
# i.e. A/B/C.hs contains the module A.B.C
#
# The file hugs/exclude (if present in the source directory) contains
# a list of modules that aren't to be used with Hugs, one per line,
# possibly with commentary on the rest of the line.

usage="$0 <source-directory> <target-directory>"

cpp_flags='-D__HUGS__'

cpp=${cpp-gcc -P -E -traditional -xc}
cc=${CC-gcc}
hsc2hs=${hsc2hs-hsc2hs}

# platform sensitive settings
case `uname -a` in
*CYGWIN*) # For Win32
	CALLCONV=stdcall ;;
*)	CALLCONV=ccall ;;
esac

case $# in
2)	;;
*)	echo "usage: $usage" >&2
	exit 1 ;;
esac

source_dir=$1
target_dir=$2

if [ ! -d $source_dir ]; then
	echo "Can't find directory '$1'" >&2
	exit 1
fi

includes="-I. -I.. -I$source_dir/include"
tmpdir=/tmp/cvt.$$

[ -d $tmpdir ] && rm -r $tmpdir

extract_includes() {
	sed -n 's/^{-# OPTIONS -\(#include .*\) #-}/\1/p' $*
}

hack_foreign() {
	sed '	/^foreign[	 ]/ {
			s/"\([^ ]*\)"/"'"$1"' \1"/
			s/CALLCONV/'"$CALLCONV"'/
		}'
}

(
	cd $source_dir
	find . \( -name '[a-z]*' -o -name GHC -o -name NHC \) -prune -o \
		\( -name \*.hs -o -name \*.lhs -o -name \*.hsc \
			-o -name \*.y -o -name \*.ly \) -print |
		sed '	s:^\./::
			s/\..*//' |
		sort -u
	if [ -f hugs/exclude ]; then
		sed '	/^[	]*#/ d
			/^[ 	]*$/ d
			s/[ 	].*//
			s:\.:/:g' hugs/exclude | sort -u
	fi
) | sort | uniq -u | while read modname; do
	echo "Converting $modname"

	stem=$source_dir/$modname
	target_stem=$target_dir/$modname
	dstdir=`dirname $target_stem`
	basename=`basename $stem`

	mkdir -p $dstdir

	# Prefer *_hsc_make.c to *.hsc, and *.hs to *.[l]y,
	# so that if these are present we don't need hsc2hs and happy.
	# (But don't take .hs if .hsc is present.)

	if [ -f ${stem}_hsc_make.c ]; then
		# with hacks to extract the -#include directives and
		# to substitute CALLCONV in Network.Socket (ugh)
		header="${basename}_aux.h"

		# don't run hsc2hs if its output is already present
		hsc_make="${target_stem}_hsc_make"
		$cc $cpp_flags $includes -o "$hsc_make" "${stem}_hsc_make.c"
		$hsc_make | hack_foreign $header >$target_stem.hs
		rm "$hsc_make"

		extract_includes $target_stem.hs >"$dstdir/$header"
	elif [ -f $stem.hsc ]; then
		# with hacks to extract the -#include directives and
		# to substitute CALLCONV in Network.Socket (ugh)
		header="${basename}_aux.h"

		copy="$target_stem.hsc"
		hack_foreign $header <$stem.hsc >$copy
		$hsc2hs --cc="$cc" $cpp_flags $includes "$copy"
		rm "$copy"

		extract_includes $target_stem.hs >"$dstdir/$header"
	elif [ -f $stem.hs ]; then
		$cpp $cpp_flags $includes $stem.hs | cat -s >$target_stem.hs
	elif [ -f $stem.lhs ]; then
		$cpp $cpp_flags $includes $stem.lhs | cat -s >$target_stem.lhs
	elif [ -f $stem.y ]; then
		mkdir $tmpdir
		cp $stem.y $tmpdir
		(
			cd $tmpdir
			happy $basename.y
		)
		$cpp $cpp_flags $tmpdir/$basename.hs | cat -s >$target_stem.hs
		rm -r $tmpdir
	elif [ -f $stem.ly ]; then
		mkdir $tmpdir
		cp $stem.ly $tmpdir
		(
			cd $tmpdir
			happy $basename.ly
		)
		$cpp $cpp_flags $tmpdir/$basename.hs | cat -s >$target_stem.hs
		rm -r $tmpdir
	else
		echo "$0: don't know how to handle $stem" >&2
	fi
done
