#! /bin/sh
# @configure_input@

# Convert a Haskell package for use by Hugs

usage="$0 source-dir [target-dir]"

# The source directory is assumed to be the root of a package hierarchy,
# i.e. A/B/C.hs contains the module A.B.C
#
# The file hugs/exclude (if present in the source directory) contains
# a list of modules that aren't to be used with Hugs, one per line,
# possibly with commentary on the rest of the line.
#
# Several packages may be put into the same target directory, as long as
# they don't overlap (which they aren't supposed to).

cpp_flags='-D__HUGS__'

cc=${CC-@CC@}
: ${cpp='@CPP_TRADITIONAL@'}
: ${happy=happy}
: ${hsc2hs=hsc2hs}
: ${greencard=greencard}
: ${ffihugs=ffihugs}
: ${runhugs=runhugs}
: ${HUGSDIR=@HUGSDIR@}
: ${SORT=@SortCmd@}
: ${FIND=@FindCmd@}
HUGSFLAGS=

export HUGSDIR HUGSFLAGS

EXEEXT=@EXEEXT@

case `uname -a` in
*CYGWIN*) platform=Win32 ;;
*)	platform=Unix ;;
esac

# platform sensitive settings
case $platform in
Win32)	CALLCONV=stdcall
	tmpdir_root=`cygpath -w /tmp | sed -e 's%\\\\%/%g' `;;
*)	CALLCONV=ccall
	tmpdir_root="/tmp" ;;
esac
cpp_flags="$cpp_flags -DCALLCONV=$CALLCONV"

while [ $# -gt 0 ]
do	case $1 in
	-*)	echo "$0: unrecognized option '$1'" >&2
		echo "usage: $usage" >&2
		exit 1 ;;
	*)	break ;;
	esac
done

case $# in
1)	target_dir=$HUGSDIR/libraries ;;
2)	target_dir=$2 ;;
*)	echo "usage: $usage" >&2
	exit 1 ;;
esac

source_dir=$1

if [ ! -d $source_dir ]; then
	echo "Can't find directory '$1'" >&2
	exit 1
fi

# Canonicalize win32 paths 
# (i.e., stay far away from unportable /cygdrive-paths)
case $platform in
Win32)	# stay away from -m (older versions of 'cygpath' doesn't support it.)
	[ -n "${source_dir}" ] &&
		source_dir=`cygpath -w $source_dir | sed -e 's@\\\\@/@g'`
	[ -n "${HUGSDIR}" ] &&
		HUGSDIR=`cygpath -w $HUGSDIR | sed -e 's@\\\\@/@g'`
	[ -n "${target}" ] &&
		target=`cygpath -w $target | sed -e 's@\\\\@/@g'`
esac

includes="-I$HUGSDIR/include -I$source_dir/include"

# configure the library package first

if test -x $source_dir/configure; then
	(cd $source_dir; ./configure)
fi

# create all scratch files in $tmpdir

tmpdir=$tmpdir_root/cvt.$$
[ -d $tmpdir ] && rm -r $tmpdir
trap "rm -rf $tmpdir; exit 0" 0 1 2 3 15
mkdir $tmpdir

# Preprocess the argument file with the C preprocessor
# usage: through_cpp filename cpp-args

# for portability, we run the preprocessor on a .c file.
tmp_cfile=$tmpdir/cppinput.c

through_cpp() {
	cp $1 $tmp_cfile
	shift
	# gcc-3.3 on MacOS X 10.3 is reported to add #pragma
	$cpp $cpp_flags $includes "$@" $tmp_cfile | grep -v '^#' | cat -s
}

# Determine the list of modules to be converted

module_list=$tmpdir/list.1
all_modules=$tmpdir/list.2

(
	cd $source_dir
	$FIND . \( -name '[a-z]*' -o -name GHC -o -name NHC \) -prune -o \
		\( -name \*.hs -o -name \*.lhs -o -name \*.hsc \
			-o -name \*.y -o -name \*.ly -o -name \*.gc \) -print |
		sed '	s:^\./::
			s/\..*//' |
		$SORT -u >$all_modules

	if [ -f hugs/exclude ]; then
		sed '	/^[	]*#/ d
			/^[ 	]*$/ d
			s/[ 	].*//
			s:\.:/:g' hugs/exclude |
		$SORT -u | comm -13 - $all_modules >$module_list
	else
		mv $all_modules $module_list
	fi
)

# Pass 1: preprocess modules

while read modname
do	echo "Converting $modname"

	stem=$source_dir/$modname
	target_stem=$target_dir/$modname
	dstdir=`dirname $target_stem`
	basename=`basename $stem`

	mkdir -p $dstdir

	# Prefer *_hsc_make.c to *.hsc, and *.hs to *.[l]y,
	# so that if these are present we don't need hsc2hs and happy.
	# (But don't take .hs if .hsc is present.)

	if [ -f ${stem}_hsc_make.c ]; then
		# don't run hsc2hs if its output is already present
		hsc_make="${target_stem}_hsc_make"
		$cc $cpp_flags $includes -o "$hsc_make" "${stem}_hsc_make.c"
		$hsc_make | sed "s/CALLCONV/$CALLCONV/g" >$target_stem.hs
		rm "$hsc_make${EXEEXT}"
	elif [ -f $stem.hsc ]; then
		sed "s/CALLCONV/$CALLCONV/g" "$stem.hsc" >"$target_stem.hsc"
		$hsc2hs --cc="$cc" $cpp_flags $includes "$target_stem.hsc"
		rm "$target_stem.hsc"
	elif [ -f $stem.gc ]; then
		abs_src_dir=`cd $source_dir; pwd`
		(
			cd $target_dir
			$greencard -t ffi -i $abs_src_dir $modname.gc
		)
	elif [ -f $stem.hs ]; then
		through_cpp $stem.hs >$target_stem.hs
	elif [ -f $stem.lhs ]; then
		through_cpp $stem.lhs >$target_stem.lhs
	elif [ -f $stem.y ]; then
		cp $stem.y $tmpdir
		(
			cd $tmpdir
			$happy $basename.y
		)
		through_cpp $tmpdir/$basename.hs >$target_stem.hs
	elif [ -f $stem.ly ]; then
		cp $stem.ly $tmpdir
		(
			cd $tmpdir
			$happy $basename.ly
		)
		through_cpp $tmpdir/$basename.hs >$target_stem.hs
	else
		echo "$0: don't know how to handle $stem" >&2
	fi
done <$module_list

# Pass 2: compile FFI modules

conf_in=$source_dir/package.conf.in

if [ -f "$conf_in" ]
then	conf=$tmpdir/package.conf
	through_cpp $conf_in -DLIBDIR= -DLIBRARY= >$conf
else
	conf=`echo $source_dir/*.conf`
fi

# Get values from the package description file

get_pkg_field() {
	$runhugs -98 $HUGSDIR/tools/get_pkg_field "$1" $conf | tr -d '",'
}

extra_libraries=
extra_ld_opts=
extra_cc_opts=
c_includes=
if [ -f "$conf" ]
then	extra_libraries=`get_pkg_field extra-libs | sed 's/HS[^ ]*_cbits *//'`
	extra_ld_opts=`get_pkg_field extra-ld-opts`
	extra_cc_opts=`get_pkg_field extra-cc-opts`
	c_includes=`get_pkg_field includes`
	extra_frameworks=`get_pkg_field extra-frameworks`
fi

while read modname
do
	stem=$target_dir/$modname
	if [ -f $stem.lhs ]
	then	filename=$stem.lhs
	else	filename=$stem.hs
	fi

	# Crude test for foreign declarations.
	# Running ffihugs on a few extras does no harm.

	if grep '^>*[ 	]*foreign[ 	][ 	]*[ei][mx]port' $filename >/dev/null
	then
		dstdir=`dirname $filename`

		cmd="$ffihugs -98 -P$target_dir:"

		# Determine the list of headers used by the file
		# bug: <foo.h> and "foo.h" will not be unified
		header_list=$tmpdir/list.hdrs
		(
			for h in $c_includes
			do	echo "\"$h\""
			done
			sed -n 's/^>* *{-# \(OPTIONS.*-#include\|INCLUDE\)  *\([^ ]*\).*/\2/p' $filename
		) | $SORT -u >$header_list
		for h in `cat $header_list`
		do	cmd="$cmd +i$h"
		done

		cmd="$cmd $filename"

		for flag in -I$dstdir -I$source_dir/include
		do	cmd="$cmd $flag"
		done
		for file in `sed -n 's/{-# CFILES \(.*\) #-}/\1/p' $filename`
		do	case "$file" in
			/*)	cmd="$cmd $file" ;;
			*)	cmd="$cmd $source_dir/$file" ;;
			esac
		done
		for flag in $extra_ld_opts $extra_cc_opts
		do	cmd="$cmd $flag"
		done
		for lib in $extra_libraries
		do	if test "$platform" = Win32 && test "$cc" != gcc; then
				cmd="$cmd $lib.lib"
			else
				cmd="$cmd -l$lib"
			fi
		done
		for framework in $extra_frameworks
		do	cmd="$cmd -framework $framework"
		done

		echo "Compiling $filename"
		$cmd
	fi
done <$module_list
