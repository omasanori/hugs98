Documentation on options not covered by the user's manual.
==========================================================

Generate FFI code: {+,-}G
-------------------------

See ffi-notes.txt

Qualify names when printing, {+,-}Q
-----------------------------------

By default, the interpreter will print out names without qualifying
them with their defining modules. Most of the time that's exactly what
you want, but can become confusing if you re-define types and
functions; the error messages not pinning down what entity it is
referring to. To have the interpreter qualify the names, use +Q.
Typically, you use +Q when resolving errors, but turn it back off
again afterwards.

Default: -Q

Allow overlapping instances: {+,-}o
-----------------------------------

Allow unsafe overlapping instances: {+,-}O
------------------------------------------

Display results of IO programs : {+,-}I
---------------------------------------

When +I is used, evaluating an IO action at the prompt is
wrapped up together with Prelude.print to show the result --

  Prelude> :set +I
  Prelude> (return 'a' :: IO Char)
  'a'
  Prelude> 

i.e., if 'm' is the IO action being evaluated, using +I is
identical to  "do { x <- m ; print x }"

Default: -I (IO action is performed, but its result isn't printed.)

Support 'here documents': {+,-}H
--------------------------------

A 'here document' (named after similar things in Unix shells) is
another way of writing string literals, often useful for large strings.
Everything from `` to '' (including newlines and backslashes, but
not $ characters) is treated as literal text, and layout is ignored.
The exception is the $ character, so that you can embed the value of
the variable var in the string by writing $(var).  To get a literal $
character, write $$ -- single $ characters are not allowed.

This extension is turned off by default.  When +H is given, the following

	letter name = ``Dear $(name),
Here are some characters: \ ' ` ".
To learn more, send $$10 to the address below.''

is equivalent the Haskell 98 declaration

	letter name = "Dear " ++ quote name ++ ",\n\
		      \Here are some characters: \\ ' ` \".\n\
		      \To learn more, send $10 to the address below."

The function

	class Quote where
		quote :: a -> String

(basically no change for String and Char, and show for everything else)
comes from the Quote module, which also defines several common instances,
and should be imported if you use the $(var) form.  (This module also
requires the -98 option.)

Defaulting types before printing: {+,-}T
----------------------------------------

When printing out types, the interpreter will not try to
simplify types by applying Haskell's defaulting rules for
numeric types, e.g.,

  Prelude> :t 1
  1 :: Num a => a
  Prelude> 

Should you want to have the interpreter attempt to 'default'
types first, turn on the 'T' toggle, i.e., use +T.

  Prelude> :set +T
  Prelude> :t 1
  1 :: Integer
  Prelude> 

Default: -T

Use old implicit parameter syntax: {+,-}W
-----------------------------------------

With the -98 option, Hugs supports implicit parameters, as described
in "Implicit parameters: dynamic scoping with static types", J Lewis,
MB Shields, E Meijer, J Launchbury, 27th ACM Symposium on Principles of
Programming Languages (POPL'00), Boston, Jan 2000.  The syntax used in
that paper, using new keywords 'dlet' and 'with', is now deprecated in
favour of the form

	let ?var = exp in exp

The old syntax is still supported, unless the -W option is given.  (If +98
is in effect, neither syntax is available.)  This frees 'dlet' and 'with'
for use by programs, and is required by some libraries, e.g. Foreign.

Add loaded module's directory to search path: {+,-}X
----------------------------------------------------

By default, the interpreter adds the directory of the file being
loaded to its import search path. This is so that when resolving
an import of a module named A (say), you'll pick up A from the
directory of the loaded file, if present. This fits nicely with
the scenario when you invoke Hugs as follows (either directly
or via GUI shell file associations):

   hugs /path/to/my/project/code.hs

avoiding the user from having to explicitly add "/path/to/my/project/"
to his/her search path first. 

This behaviour does introduce a potential problem when used in
conjunction with hierarchical module names though. Consider
the modules A.B.C and A.B.Char, with A.B.C containing an
import of the Haskell98 module Char. When Hugs loads up
A/B/C.hs, it adds A/B/ to its search path. This will cause
the interpreter to resolve the import of 'Char' to 
A/B/Char, which is wrong. 

However the impact is slight, because hierarchical modules tend to
import other modules with compound names. If the module A.B.C had
imported the same module by its longer name Data.Char, no confusion
would arise unless A/B/Data/Char.hs were found. In particular,
the hierarchical libraries provided with Hugs are unaffected.

Set list of filename suffixes: -S
---------------------------------

Normally, when you import a module Foo, Hugs looks for files Foo.hs
and Foo.lhs in each directory in you search path.  With this option,
you can change this list, in a similar way to the -P option for the
search path.  By default, the suffix list is ".hs:.lhs", which gives
the behaviour just described.  (NB: the ":" is the Unix separator.
Windows or Macs use ";" instead.)  If you use -S:.xhs then the suffix
list becomes ".hs:.lhs:.xhs", so Hugs will look for Foo.hs, Foo.lhs
and Foo.xhs.

The interpreter won't let you change the suffix list if that would
prevent it from reading the Prelude, i.e. you must include ".hs".
Note also that the interpreter knows that files ending in ".lhs"
are literate scripts; no other suffix is treated that way.

This option can be useful in conjunction with the preprocessor option
(-F).  The preprocessor can examine the filename to decide what to
do with the file.
