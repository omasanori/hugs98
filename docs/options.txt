Documentation on options not covered by the user's manual.
==========================================================

Generate FFI code: {+,-}G
-------------------------

Qualify names when printing, {+,-}Q
-----------------------------------

By default, the interpreter will print out names without qualifying
them with their defining modules. Most of the time that's exactly what
you want, but can become confusing if you re-define types and
functions; the error messages not pinning down what entity it is
referring to. To have the interpreter qualify the names, use +Q.
Typically, you use +Q when resolving errors, but turn it back off
again afterwards.

Default: -Q

Allow overlapping instances: {+,-}o
-----------------------------------

Allow unsafe overlapping instances: {+,-}O
------------------------------------------

Display results of IO programs : {+,-}I
---------------------------------------

Support 'here documents': {+,-}H
--------------------------------

Defaulting types before printing: {+,-}T
----------------------------------------

Use old implicit parameter syntax: {+,-}W
-----------------------------------------

With the -98 option, Hugs supports implicit parameters, as described
in "Implicit parameters: dynamic scoping with static types", J Lewis,
MB Shields, E Meijer, J Launchbury, 27th ACM Symposium on Principles of
Programming Languages (POPL'00), Boston, Jan 2000.  The syntax used in
that paper, using new keywords 'dlet' and 'with', is now deprecated in
favour of the form

	let ?var = exp in exp

The old syntax is still supported, unless the -W option is given.  (If +98
is in effect, neither syntax is available.)  This frees 'dlet' and 'with'
for use by programs, and is required by some libraries, e.g. Foreign.

Add loading module's path to search path: {+,-}X
------------------------------------------------

Use hierarchical libraries: {+,-}N
----------------------------------

Hugs98 offers you a choice of what kind of standard library setup to
use at startup: the Haskell 98-based library setup used by all
previous Hugs releases, or the new, hierarchical Haskell libraries (as
already provided by NHC and GHC.)

The latter is what all Haskell systems are moving towards; it offers
more flexibility and functionality over the flat module structure
provided by Haskell 98.  For example, the old library setup provides
a module Parsec; in the new setup, its name is

	Text.ParserCombinators.Parsec

but there is also a module called Parsec that merely imports and
re-exports this module, so your old source code should still work.
This is one major exception to this: in the old setup, the Prelude
exported several names not listed in the Haskell 98 Prelude.  The Prelude
in the new setup complies with the Haskell 98 Report.

For all its advantages, the new setup is new, so as an interim measure
the interpreter offers you the choice of staying with the old, and
well-proven, libraries.

By using +N, the default module search path will include libraries
containing the hierarchical libraries. -N enables the use of the
'standard' default library search path instead. Notice that if you
replace the default module search path rather than add to it (see the
documentation for the -P option), setting the N toggle won't have an
effect. The interpreter will warn you if this is the case.

The default is -N, but you're encouraged to move towards using +N and
the new libraries.  This will in most cases not imply any changes to old
code.  However, you might well wish to use the new, longer module names
in new code.

Set list of filename suffixes: -S
---------------------------------

Normally, when you import a module Foo, Hugs looks for files Foo.hs
and Foo.lhs in each directory in you search path.  With this option,
you can change this list, in a similar way to the -P option for the
search path.  By default, the suffix list is ".hs:.lhs", which gives
the behaviour just described.  (NB: the ":" is the Unix separator.
Windows or Macs use ";" instead.)  If you use -S:.xhs then the suffix
list becomes ".hs:.lhs:.xhs", so Hugs will look for Foo.hs, Foo.lhs
and Foo.xhs.

The interpreter won't let you change the suffix list if that would
prevent it from reading the Prelude, i.e. you must include ".hs".
Note also that the interpreter knows that files ending in ".lhs"
are literate scripts; no other suffix is treated that way.

This option can be useful in conjunction with the preprocessor option
(-F).  The preprocessor can examine the filename to decide what to
do with the file.
