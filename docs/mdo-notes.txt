Recursive Monadic Bindings:
---------------------------

Hugs supports the recursive-do notation, an extension to the do-notation 
that allows recursive bindings [EL00, EL02]. Note that the do-notation 
in Haskell is not recursive, that is the variables bound in a do-expression 
are visible only in the textually following code block. Compare this to a 
let-expression, where bound variables are visible in the entire binding 
group. It turns out that several applications can benefit from recursive 
bindings, and this extension provides the necessary syntactic support.

Here is a simple (yet contrived) example:

        import MonadRec

        justOnes = mdo xs <- Just (1:xs)
                       return xs

As expected, justOnes evaluates to Just [1,1,1,1,1,1,1,1,1,1,.....

There are three important points in using the recursive-do notation:

  1. The recursive version of the do-notation uses the keyword mdo (rather
     than do).
  2. The scripts using mdo should import MonadRec
  3. Hugs must be started with -98 flag

The MonadRec library introduces the MonadRec class. It's definition is:

        class Monad m => MonadRec m where
             mfix :: (a -> m a) -> m a

The MonadRec class declares the function mfix, which dictates how the
recursion should behave. If recursive bindings are required for a monad, 
then that monad must be declared an instance of the MonadRec class.
For details, see the above mentioned references.

The MonadRec library automatically declares List, Maybe, IO, and
state monads (both lazy and strict) as instances of the MonadRec class. 
 
The web page: "http://www.cse.ogi.edu/PacSoft/projects/rmb" contains
up to date information on recursive-monadic-bindings.

------------------------------------------------------------------------------

[EL00] Levent Erkök and John Launchbury. Recursive Monadic Bindings. In the
Proceedings of the International Conference on Functional Programming,
ICFP'00, pp. 174-185, 2000.

[EL02] Levent Erkök and John Launchbury. A recursive do for Haskell. In
the Proceedings of the Haskell Workshop'02, pp. 29-37, 2002.
