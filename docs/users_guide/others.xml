<chapter id="others">
<title>Other ways of running Hugs</title>

<sect1 id="runhugs">
<title>Running standalone Haskell programs</title>

<cmdsynopsis>
<command>runhugs</command>
<arg rep="repeat" choice="opt"><replaceable>option</replaceable></arg>
<arg choice="plain"><replaceable>file</replaceable></arg>
<arg rep="repeat" choice="opt"><replaceable>argument</replaceable></arg>
</cmdsynopsis>

<para>
The <command>runhugs</command> command is an interpreter for an executable Hugs
script.
The first non-option should be the name of a file containing a Haskell
<literal>Main</literal> module.
The <command>runhugs</command> command will invoke the
the <function>main</function> function in this module, with any subsequent
arguments available through the <function>getArgs</function> action.
</para>

<para>
For example, suppose we have a file <filename>echo.hs</filename> containing
<programlisting>
module Main where

import System.Environment

main = do
        args &lt;- getArgs
        putStrLn (unwords args)
</programlisting>
Then we can run this program with the command
<screen>
runhugs echo.hs a b c
</screen>
We can also test the program from within the interpreter
using the <function>withArgs</function> function from the
<literal>System.Environment</literal> module:
<screen>
Main> withArgs ["a", "b", "c"] main
a b c
</screen>
</para>

<para>
On Unix systems, it is possible for an executable file to specify which
program is used to run it.
To do this we need to make the module a literate script, like the following:
<programlisting>
#! /usr/local/bin/runhugs +l

> module Main where

> import System.Environment

> main = do
>       args &lt;- getArgs
>       putStrLn (unwords args)
</programlisting>
If this file is called <filename>myecho</filename>, and is executable,
we can say
<screen>
myecho a b c
</screen>
This invokes the command
<screen>
/usr/local/bin/runhugs +l myecho a b c
</screen>
The <link linkend="option-literate"><option>+l</option></link> option tells
<command>runhugs</command> that <filename>myecho</filename> contains a
literate script,
even though its name does not end in <quote><literal>.lhs</literal></quote>.
</para>

<note>
<para>
Unfortunately, the <literal>#!</literal> feature passes additional arguments
(if any) to the program as a single argument: if the first line were
<programlisting>
#! /usr/local/bin/runhugs +l -98
</programlisting>
then the first argument to <command>runhugs</command> would be
<quote><literal>+l -98</literal></quote>.
You can get around this using the
<link linkend="option-split-options"><option>-X</option></link> option,
which asks for the string to be split into options:
<programlisting>
#! /usr/local/bin/runhugs -X +l -98
</programlisting>
Then the program will read and act on both the <option>+l</option> and
<option>-98</option> options.
</para>
</note>

</sect1>

<sect1 id="ffihugs">
<title>Compiling modules that use the Foreign Function Interface</title>

<cmdsynopsis>
<command>ffihugs</command>
<arg rep="repeat" choice="opt"><replaceable>option</replaceable></arg>
<arg rep="repeat" choice="opt"><option>-i</option><replaceable>include</replaceable></arg>
<arg choice="plain"><replaceable>file</replaceable></arg>
<arg rep="repeat" choice="opt"><replaceable>cc-arg</replaceable></arg>
</cmdsynopsis>

<para>
Any module that contains <literal>foreign import</literal> declarations
must be compiled with <command>ffihugs</command> before it can be loaded
into Hugs.
</para>

<para>
Suppose you have some C functions in <filename>test.c</filename>
with some <literal>foreign import</literal> declarations for those
functions in <filename>Test.hs</filename>,
and that the code in <filename>test.c</filename> needs to be
compiled with <option>-lm</option>.
To use these with Hugs, you must first use <command>ffihugs</command>
to generate <filename>Test.c</filename>, compile it and link it against
<filename>test.c</filename> with <option>-lm</option> to produce
<filename>Test.so</filename>:
<screen>
ffihugs Test.hs test.c -lm
</screen>
Any Hugs options should be placed before the module name, as in
<screen>
ffihugs -98 Test.hs test.c -lm
</screen>
Now you can run Hugs as normal:
<screen>
hugs -98 Test.hs
</screen>
When <filename>Test.hs</filename> is loaded, Hugs will load
<filename>Test.so</filename> and then use the imported functions.
(If <filename>Test.hs</filename> depends on other modules using foreign
functions, you'll have to have compiled those modules too, but not necessarily
before compiling <filename>Test.hs</filename>.)
</para>

<para>
In the standard FFI, each <literal>foreign import</literal> declaration
should name a C header file containing the prototype of the function.
Because this is often cumbersome, <command>ffihugs</command> provides
the following additional option:
</para>

<variablelist>

<varlistentry id="option-include">
<term><option>-i</option><replaceable>include</replaceable></term>
<listitem>
<para>
Specify an include for the generated C file.
The <replaceable>include</replaceable> string should be something that
can follow <quote><literal>#include</literal></quote> in a C program, as in
<screen>
ffihugs '-i&lt;math.h&gt;' '-i"mydefs.h"' Test.hs test.c -lm
</screen>
Note the necessary quoting of the <option>-i</option> options here.
</para>
</listitem>
</varlistentry>

</variablelist>

</sect1>

<sect1 id="winhugs">
<title>Graphical interface for Windows</title>

<para>Some brief details of winhugs needed here.</para>

</sect1>

</chapter>
