<chapter id="commands">
<title>Hugs commands</title>

<para>
Hugs starts with a banner like
<screen>
  __   __ __  __  ____   ___      _________________________________________
  ||   || ||  || ||  || ||__      Hugs 98: Based on the Haskell 98 standard
  ||___|| ||__|| ||__||  __||     Copyright (c) 1994-2003
  ||---||         ___||           World Wide Web: http://haskell.org/hugs
  ||   ||                         Report bugs to: hugs-bugs@haskell.org
  ||   || Version: March 2003     _________________________________________

  Haskell 98 mode: Restart with command line option -98 to enable extensions

  Type :? for help
  Prelude>
</screen>
The prompt string <literal>Prelude></literal> indicates that the current
module is the Haskell <literal>Prelude</literal>.
At this prompt, you can type expressions to evaluate,
and also commands of the form
<quote><command>:<replaceable>cmd</replaceable></command></quote>,
where <replaceable>cmd</replaceable> may be abbreviated to a single letter.
</para>

<sect1 id="basic-commands">
<title>Basic operation</title>
<variablelist>

<varlistentry id="eval-command">
<term>
<cmdsynopsis>
<arg choice=plain><replaceable>expr</replaceable></arg>
</cmdsynopsis>
</term>

<listitem>
<para>
Evaluate the expression.
The expression cannot be broken over multiple lines.
Usually, the value is simply converted to a string
(using <literal>show</literal>) and printed:
<screen>
  Prelude> 1+2
  3
</screen>
The printing style can be changed with the
<link linkend="option-use-show"><option>-u</option></link> option.
</para>

<para>
However, if <replaceable>expr</replaceable> has type
<literal>IO</literal> <replaceable>t</replaceable>
for some type <replaceable>t</replaceable>,
the resulting IO action is performed:
<screen>
  Prelude> print (1+2) >> putStrLn "bye"
  3
  bye
</screen>
Usually the value produced by this action is ignored,
but this can be changed with the
<link linkend="option-display-io"><option>+I</option></link> option.
</para>
</listitem>
</varlistentry>

<varlistentry id="type-command">
<term>
<cmdsynopsis>
<command>:type</command> <arg choice=plain><replaceable>expr</replaceable></arg>
</cmdsynopsis>
</term>

<listitem>
<para>
Print the type of <replaceable>expr</replaceable>,
without evaluating it.
</para>
</listitem>
</varlistentry>

<varlistentry id="set-command">
<term>
<cmdsynopsis>
<command>:set</command> <arg rep=repeat><replaceable>option</replaceable></arg>
</cmdsynopsis>
</term>

<listitem>
<para>
Set command line options.
See <xref linkend="options-list"> for a list of available options.
</para>
<para>
If no options are given, list the available options and their current settings.
</para>
</listitem>
</varlistentry>

<varlistentry id="quit-command">
<term>
<cmdsynopsis>
<command>:quit</command>
</cmdsynopsis>
</term>

<listitem>
<para>
Exit the interpreter.
</para>
</listitem>
</varlistentry>

</variablelist>
</sect1>

<sect1 id="module-commands">
<title>Loading and editing Haskell module files</title>

<para>
Hugs assumes that each Haskell module is in a separate file.
You can load these files by name, or by specifying a module name.
</para>

<para>
Hugs maintains a notion of a <emphasis>current module</emphasis>,
initially the <literal>Prelude</literal> and normally indicated by the prompt.
Expressions presented to Hugs are interpreted within the scope of the
current module, i.e. they may refer to unexported names within the module.
</para>

<variablelist>

<varlistentry id="load-command">
<term>
<cmdsynopsis>
<command>:load</command>
<arg rep=repeat><replaceable>file-or-module</replaceable></arg>
</cmdsynopsis>
</term>

<listitem>
<para>
Clear all files except the <literal>Prelude</literal> and modules it uses,
and then load the specified files or modules (if any).
The last module loaded becomes the current module.
</para>

<para>
When asked to load a module <replaceable>M</replaceable>,
Hugs looks for a file
<replaceable>dir</replaceable><literal>/</literal><replaceable>M</replaceable><literal>.hs</literal>
or
<replaceable>dir</replaceable><literal>/</literal><replaceable>M</replaceable><literal>.lhs</literal>,
where <replaceable>dir</replaceable> is a directory in its search path.
(The <quote><literal>/</literal></quote> is used on Unix systems;
Windows systems use <quote><literal>\</literal></quote>.)
The search path may be changed using the
<link linkend="option-search-path"><option>-P</option></link> option,
while the set of suffixes tried may be changed using the
<link linkend="option-suffixes"><option>-S</option></link> option.
</para>

<para>
In mapping compound module names like <literal>A.B.C</literal> to files,
the dots are interpreted as slashes, leading to filenames
<replaceable>dir</replaceable><literal>/A/B/C.hs</literal>
or
<replaceable>dir</replaceable><literal>/A/B/C.lhs</literal>.

<para>
Modules imported by Haskell modules are resolved to filenames in the same way,
except that an extra directory is searched first when
</para>
<itemizedlist>
<listitem>
<para>
the importing module was loaded by specifying a filename in that directory, or
</listitem>

<listitem>
<para>
the importing module was found relative to that directory.
</para>
</listitem>
</itemizedlist>
<para>
This fits nicely with the scenario where you load a module
<screen>
  Prelude> :load /path/to/my/project/code.hs
  Main>
</screen>
where the directory <literal>/path/to/my/project</literal> contains other
modules used directly or indirectly by the module <literal>Main</literal>
in <literal>code.hs</literal>.
For example, suppose <literal>Main</literal> imports <literal>A.B.C</literal>,
which in turn imports <literal>D</literal>.
These may be resolved to filenames
<literal>/path/to/my/project/A/B/C.hs</literal>,
and (assuming that is found), <literal>/path/to/my/project/D.hs</literal>.
However imports from modules found on the search path do not use the extra
directory.

</listitem>
</varlistentry>

<varlistentry id="also-command">
<term>
<cmdsynopsis>
<command>:also</command>
<arg rep=repeat><replaceable>file-or-module</replaceable></arg>
</cmdsynopsis>
</term>

<listitem>
<para>
Read the specified additional files or modules.
The last module loaded becomes the current module.
</para>
</listitem>
</varlistentry>

<varlistentry id="reload-command">
<term>
<cmdsynopsis>
<command>:reload</command>
</cmdsynopsis>
</term>

<listitem>
<para>
Clear all files except the <literal>Prelude</literal> and modules it uses,
and then reload all the previously loaded modules.
</para>
</listitem>
</varlistentry>

<varlistentry id="module-command">
<term>
<cmdsynopsis>
<command>:module</command> <arg choice=plain><replaceable>module</replaceable></arg>
</cmdsynopsis>
</term>

<listitem>
<para>
Set module for evaluating expressions.
</para>
</listitem>
</varlistentry>

<varlistentry id="edit-command">
<term>
<cmdsynopsis>
<command>:edit</command> <arg choice=opt><replaceable>file</replaceable></arg>
</cmdsynopsis>
</term>

<listitem>
<para>
The <literal>:edit</literal> command starts an editor program to modify
or view a Haskell module.
Hugs suspends until the editor terminates,
and then reloads the currently loaded modules.
The <option>-E</option> option (see <xref linkend="options-editor">)
can be used to configure Hugs to your editor of choice.
</para>

<para>
If no filename is specified, Hugs edits the current module.
</para>

</listitem>
</varlistentry>

<varlistentry id="find-command">
<term>
<cmdsynopsis>
<command>:find</command> <arg choice=plain><replaceable>name</replaceable></arg>
</cmdsynopsis>
</term>

<listitem>
<para>
edit module containing definition of <replaceable>name</replaceable>.
</para>
</listitem>
</varlistentry>

</variablelist>
</sect1>

<sect1 id="info-commands">
<title>Getting information</title>
<variablelist>

<varlistentry id="help-command">
<term>
<cmdsynopsis>
<command>:?</command>
</cmdsynopsis>
</term>

<listitem>
<para>
Display a brief summary of commands.
</para>
</listitem>
</varlistentry>

<varlistentry id="names-command">
<term>
<cmdsynopsis>
<command>:names</command> <arg rep=repeat choice=opt><replaceable>pattern</replaceable></arg>
</cmdsynopsis>
</term>

<listitem>
<para>
List names that match any of the listed patterns
and are defined in any of the currently loaded modules.
Patterns resemble filename patterns:
<literal>*</literal> matches any substring,
<literal>?</literal> matches any chararacter,
<literal>[</literal><replaceable>chars</replaceable><literal>]</literal>
matches any of <replaceable>chars</replaceable>,
with <replaceable>char</replaceable><literal>-</literal><replaceable>char</replaceable>
standing for a range of characters, and
<literal>\</literal><replaceable>char</replaceable> matches <replaceable>char</replaceable>.
</para>

<para>
If no patterns are given,
all names defined in any of the currently loaded modules are listed.
</para>
</listitem>
</varlistentry>

<varlistentry id="info-command">
<term>
<cmdsynopsis>
<command>:info</command> <arg choice=opt><replaceable>name</replaceable></arg>
</cmdsynopsis>
</term>

<listitem>
<para>
Describe the named objects.
Qualified names may be used for
objects defined or imported in any loaded module other than the current one.
</para>

<para>
If no arguments are given, the names of all currently loaded files are printed.
</para>
</listitem>
</varlistentry>

<varlistentry id="browse-command">
<term>
<cmdsynopsis>
<command>:browse</command> <arg choice=opt><option>all</option></arg> <arg rep=repeat choice=opt><replaceable>module</replaceable></arg>
</cmdsynopsis>
</term>

<listitem>
<para>
List names exported by the specified modules (which must already be loaded).
If <quote><option>all</option></quote> is given,
list all names in scope inside the modules.
If no modules are given, it describes the current module.
</para>
</listitem>
</varlistentry>

<varlistentry id="version-command">
<term>
<cmdsynopsis>
<command>:version</command>
</cmdsynopsis>
</term>

<listitem>
<para>
Print Hugs version.
</para>
</listitem>
</varlistentry>

</variablelist>
</sect1>

<sect1 id="misc-commands">
<title>Miscellaneous commands</title>
<variablelist>

<varlistentry id="shell-command">
<term>
<cmdsynopsis>
<command>:!</command><arg choice=opt><replaceable>command</replaceable></arg>
</cmdsynopsis>
</term>

<listitem>
<para>
Shell escape.
If the <replaceable>command</replaceable> is omitted, run a shell.
</para>
</listitem>
</varlistentry>

<varlistentry id="cd-command">
<term>
<cmdsynopsis>
<command>:cd</command> <arg choice=plain><replaceable>dir</replaceable></arg>
</cmdsynopsis>
</term>

<listitem>
<para>
Change the working directory of Hugs to <replaceable>dir</replaceable>.
If <replaceable>dir</replaceable> begins with
<quote><literal>~/</literal></quote>,
the <quote><literal>~</literal></quote> is replaced by your home directory.
</para>
</listitem>
</varlistentry>

<varlistentry id="gc-command">
<term>
<cmdsynopsis>
<command>:gc</command>
</cmdsynopsis>
</term>

<listitem>
<para>
Force a garbage collection.
</para>
</listitem>
</varlistentry>

</variablelist>
</sect1>

</chapter>
