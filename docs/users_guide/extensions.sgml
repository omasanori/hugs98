<chapter id="extensions">
<title>Non-standard language extensions</title>

<para>Several experimental features are enabled with the <option>-98</option>
option.
Most are described in
<ulink url="http://cvs.haskell.org/Hugs/pages/hugsman/exts.html">Section 7 of the <citetitle pubwork=article>Hugs 98 User Manual</citetitle></ulink>.
</para>

<para>
Most of these extensions are also supported by
<ulink url="http://www.haskell.org/ghc/">GHC</ulink>,
the principal exception being TRex (typed extensible records).
GHC provides some of these extensions in a more general form.
</para>

<sect1 id="recursive-do">
<title>Recursive do-notation</title>

<para>
The recursive do-notation (also known as mdo-notation) is implemented
as described in:

    <citetitle pubwork=article>A recursive do for Haskell</citetitle>,
    Levent Erkok and John Launchbury,
    <citetitle pubwork=book>Haskell Workshop 2002</citetitle>,
    pages: 29&ndash;37. Pittsburgh, Pennsylvania.
</para>

<para>
The do-notation of Haskell does not allow recursive bindings, that is,
the variables bound in a do-expression are visible only in the textually
following code block. Compare this to a let-expression, where bound
variables are visible in the entire binding group. It turns out that
several applications can benefit from recursive bindings in the do-notation,
and this extension provides the necessary syntactic support.
</para>

<para>
Here is a simple (yet contrived) example:
<programlisting>
  import Control.Monad.Fix

  justOnes = mdo xs <- Just (1:xs)
                 return xs
</programlisting>
As you can guess <literal>justOnes</literal> will evaluate to
<literal>Just [1,1,1,...</literal>
</para>

<para>
The <literal>Control.Monad.Fix</literal> module introduces
the <literal>MonadFix</literal> class, defined as
<programlisting>
  class Monad m => MonadFix m where
      mfix :: (a -> m a) -> m a
</programlisting>
The function <literal>mfix</literal> dictates how the required recursion
operation should be performed.
If recursive bindings are required for a monad, then that
monad must be declared an instance of the <literal>MonadFix</literal> class.
For details, see the above mentioned reference.
</para>

<para>
The <literal>Control.Monad.Fix</literal> module also defines instances of
<literal>MonadFix</literal> for <literal>List</literal>,
<literal>Maybe</literal> and <literal>IO</literal>.
Furthermore, several other monad modules provide instances of the
<literal>MonadFix</literal> class, including
the <literal>Control.Monad.ST</literal> and
<literal>Control.Monad.ST.Lazy</literal>
modules for Haskell's internal state monad (strict and lazy, respectively).
</para>

<para>
There are three important points in using the recursive-do notation:
<itemizedlist>
<listitem><para>
The recursive version of the do-notation uses
the keyword <literal>mdo</literal> (rather than <literal>do</literal>).
</para></listitem>

<listitem><para>
You should <quote><literal>import Control.Monad.Fix</literal></quote>.
</para></listitem>

<listitem><para>
Hugs should be started with the flag <option>-98</option>.
</para></listitem>
</itemizedlist>
The web page: <quote><ulink url="http://www.cse.ogi.edu/PacSoft/projects/rmb">http://www.cse.ogi.edu/PacSoft/projects/rmb</ulink></quote>
contains up to date information on recursive monadic bindings.
</para>

<para>
Historical note: The old implementation of the mdo-notation (and most
of the existing documents) used the name <literal>MonadRec</literal>
for the class and the corresponding library.
</para>

</sect1>

<sect1 id="zip-comprehension">
<title>Parallel list comprehensions (a.k.a. zip-comprehensions)</title>

<para>
Parallel list comprehensions are a natural extension to list comprehensions.
List comprehensions can be thought of as a nice syntax for writing maps and
filters.
Parallel comprehensions extend this to include the <literal>zipWith</literal>
family.
</para>

<para>
A parallel list comprehension has multiple independent branches of qualifier
lists, each separated by a <quote><literal>|</literal></quote> symbol.
For example, the following zips together two lists:
<programlisting>
   [ (x, y) | x <- xs | y <- ys ]
</programlisting>
The behavior of parallel list comprehensions follows that
of <literal>zip</literal>, in that
the resulting list will have the same length as the shortest branch.
</para>

<para>
We can define parallel list comprehensions by translation to regular
comprehensions.
Given a parallel comprehension of the form:
<programlisting>
   [ e | p1 <- e11, p2 <- e12, ...
       | q1 <- e21, q2 <- e22, ...
       ...
   ]
</programlisting>
This will be translated to:
<programlisting>
   [ e | ((p1,p2), (q1,q2), ...) <- zipN [(p1,p2) | p1 <- e11, p2 <- e12, ...]
                                         [(q1,q2) | q1 <- e21, q2 <- e22, ...]
                                         ...
   ]
</programlisting>
where <quote><replaceable>zipN</replaceable></quote>
is the appropriate zip for the given number of branches.
</para>

</sect1>

<sect1 id="observe">
<title>Hugs debugging primitives</title>

<para>
This release of Hugs contains support for debugging by observations
inspired by the Andy Gill's Hood library:
</para>

<orderedlist>
<listitem>
<para>
Andy Gill,
<citetitle>Debugging Haskell by Observing Intermediate Data Structures</citetitle>,
in <citetitle>Draft Proceedings of the 2000 Haskell Workshop</citetitle>.
</para>
</listitem>

<listitem>
<para>
The Haskell Object Observation Debugger
<ulink url="http://www.haskell.org/hood/"></ulink>.
</para>
</listitem>
</orderedlist>

<para>
Hood is a portable Haskell library that implements the combinator
<programlisting>
  Observable a => observe :: String -> a -> a
</programlisting>
The partial application
<programlisting>
  observe tag
</programlisting>
behaves exactly like the identity function, but also records the value
of data to which it is applied.
Any observations made are reported at the end of the computation.
The <replaceable>tag</replaceable> argument is used to label the
observed value when it is reported. Non-strict semantics is preserved
&mdash; <literal>observe</literal> does not evaluate its second argument.
</para>

<para>
HugsHood uses the same observation model but differs in a number of ways.
</para>

<itemizedlist>

<listitem>
<para>
It is much faster. This is because HugsHood is implemented within the
Hugs evaluator and uses primitive builtin functions.
Performance depends upon the volume of observations. More frequent
observations incur a higher overhead. As a simple comparison, a
test program which executed 1 million reductions and made 250
observations incurred a 625 percent overhead when observations were made
with the Hood library but just 10 percent when using HugsHood.
</para>

<para>
Caveat: When not using observations, the modifications to the evaluator
to support HugsHood imposes an overhead of about 6 percent.
</para>
</listitem>

<listitem>
<para>
It is possible to easily observe arbitrary data structures.
HugsHood implements the primitive
<programlisting>
  observe :: String -> a -> a
</programlisting>
which is unconstrained by the need to build instances of the
<literal>Observable</literal> class for each user defined data type
whose values are being observed.
HugsHood uses an internal primitive function to display observed values.
This may be considered both an advantage and a disadvantage:
one does not need to define how to observe values,
but one cannot define special user views of data.
</para>
</listitem>

<listitem>
<para>
No modification to the program (apart from instrumentation with
<literal>observe</literal>) is required.
The Hood library must be invoked using a special IO monadic combinator
to ensure that observations are collected and displayed.
</para>
</listitem>

<listitem>
<para>
There are a number of minor differences in the display format which are
a consequence of the Hugs implementation. These are described below.
</para>
</listitem>

</itemizedlist>

<sect2>
<title>Using HugsHood</title>

<para>
Modules that use HugsHood combinators must import the module
<literal>Observe</literal>.
Its only role is to provide the necessary primitive definitions, namely:
<programlisting>
  primitive observe :: String -> a -> a
  primitive bkpt    :: String -> a -> a
  primitive setBkpt :: String -> Bool -> IO ()
</programlisting>

<sect3>
<title>Breakpoints</title>

<para>
HugsHood implements breakpoints. A program can be instrumented with the
<literal>bkpt</literal> function. The partial application
<screen>
  bkpt bkpt_name
</screen>
behaves exactly like the identity function, except that before it
returns its argument it checks if <replaceable>bkpt_name</replaceable>
is enabled, and if it is the user is presented with the opportunity to
view observed data.
A small set of commands is available when Hugs halts due to a breakpoint:
</para>

<variablelist>

<varlistentry>
<term>
<cmdsynopsis>
<command>p</command> <arg><replaceable>tag_name</replaceable></arg>
</cmdsynopsis>
</term>
<listitem>
<para>
Print observations made since the computation began.
If an observation tag is suppled then only the
associated observations will be displayed. Otherwise
all observations will be displayed.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<cmdsynopsis>
<command>c</command> <arg><replaceable>n</replaceable></arg>
</cmdsynopsis>
</term>
<listitem>
<para>
Continue with program evaluation. With no arguments,
evaluation will continue until another active breakpoint
is encountered. The optional numeric argument will skip
<replaceable>n</replaceable> active breakpoints before stopping.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<cmdsynopsis>
<command>s</command> <arg choice=plain><replaceable>bkpt_name</replaceable></arg>
</cmdsynopsis>
</term>
<listitem>
<para>
Set a breakpoint.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<cmdsynopsis>
<command>r</command> <arg><replaceable>bkpt_name</replaceable></arg>
</cmdsynopsis>
</term>
<listitem>
<para>
Reset a named breakpoint or, if no breakpoint name is
supplied, reset all breakpoints.
</para>
</listitem>
</varlistentry>

</variablelist>

<para>
A breakpoint is by default disabled. It can be enabled by using the
<command>s</command> command in the debug breakpoint dialogue,
or by using the <literal>setBkpt</literal> combinator.
Clearly at least one breakpoint must be enabled
using <literal>setBkpt</literal> before a breakpoint dialogue can be triggered.
</para>

</sect3>

<sect3>
<title>Breakpoint Example</title>

<para>
Here is a very simple program using the three combinators.
<programlisting>
  import Observe

  prog n = do { setBkpt "fib" True; putStr $ show (observe "fun" f n) }
  f 0 = 1
  f n = n * (bkpt "fib" $ observe "fun" f (n-1))
</programlisting>
The following sample session shows how the <command>p</command> and
<command>c</command> commands can be used.
<screen>
  Main> prog 4
  Break @ fib> p

  >>>>>>> Observations <<<<<<

  fun
    { \ 4  -> _
    }

  Break @ fib> c
  Break @ fib> p

  >>>>>>> Observations <<<<<<

  fun
    { \ 4  -> _
    , \ 3  -> _
    }

  Break @ fib> c 2
  Break @ fib> p

  >>>>>>> Observations <<<<<<

  fun
    { \ 4  -> _
    , \ 3  -> _
    , \ 2  -> _
    , \ 1  -> _
    }

  Break @ fib> c
  24
  (98 reductions, 299 cells)

  >>>>>>> Observations <<<<<<

  fun
    { \ 4  -> 24
    , \ 3  -> 6
    , \ 2  -> 2
    , \ 1  -> 1
    , \ 0  -> 1
    }

  10 observations recorded
</screen>
</para>

</sect3>

</sect2>

<sect2>
<title>Differences from Hood</title>

<para>
HugsHood uses a similar style of display to Hood, though there are
differences. One trivial difference is that Hood reports tags with a
leading <quote><literal>--</literal></quote> while HugsHood does not.
</para>

<para>
Consider now more significant differences.
</para>

<sect3>
<title>Observing character strings</title>

<para>
HugsHood (and Hood) reports lists using the cons operator.
<screen>
  Observe> observe "list" [1..3]
  [1,2,3]

  >>>>>>> Observations <<<<<<

  list
    (1 : 2 : 3 : [])
</screen>
This is too verbose for lists of characters, so HugsHood reports
strings in the usual format:
<screen>
  Observe> observe "string" ['a'..'d']
  "abcd"

  >>>>>>> Observations <<<<<<

  string
    "abcd"
</screen>
If only the initial part of the string is evaluated,
a trailing <quote><literal>...</literal></quote> is reported.
<screen>
  Observe> take 2  $ observe "string" ['a'..'d']
  "ab"

  >>>>>>> Observations <<<<<<

  string
    "ab..."
</screen>
This is clearly ambiguous, because evaluating the expression
<screen>
  observe "string" "ab..."
</screen>
will give the same result, but in practice the ambiguity
should be easy to resolve.
</para>

</sect3>

<sect3>
<title>Unevaluated expressions</title>

<para>
The <quote><literal>_</literal</quote> symbol is used to indicate
an unevaluated expression.
In Hood all unevaluated expressions will be displayed using
<quote><literal>_</literal</quote>.
In HugsHood, <quote><literal>_</literal</quote> denotes an unevaluated
expression, but not all unevaluated expressions are denoted
by <quote><literal>_</literal</quote>.
</para>

<para>
For example the expression <literal>fst $ observe "pair" (1,2)</literal> yields
<screen>
  -- pair
    (1, _)
</screen>
in both Hugs and HugsHood.
However, <literal>fst $ observe "pair" ('a','b')</literal> yields
<screen>
  pair
    ('a','b')
</screen>
in HugsHood, and <literal>('a', _)</literal> in Hood.
This is because HugsHood (unlike
Hood) does not actually record evaluation steps. It merely maintains an
internal pointer to that part of the heap representing the tagged
expression. If the expression in not in weak head normal form, then it
obviously has not been evaluated and so it is reported as just
<quote><literal>_</literal</quote>;
otherwise it displayed.  Integer constants like <literal>1</literal> and
<literal>2</literal> are not in WHNF,
as they must be coerced to the correct type when evaluated.
Characters though are in WHNF so it is not possible to discern whether
a character was evaluated.
</para>

<para>
Another consequence of the HugsHood implementation by pointers rather
than Hood's implementation by tracing evaluation is that the strictness
behaviour of a function can be masked. Consider the example:
<programlisting>
  lazy pair = let x = observe "fst" fst pair
		  y = snd pair
	      in  (y,x)
</programlisting>
For the expression <literal>lazy (1,2)</literal> Hood reports
<screen>
  -- fst
    { \ (1, _)  -> 1
    }
</screen>
while HugsHood reports
<screen>
  fst
    { \ (1,2)  -> 1
    }
</screen>
HugsHood should not be used to deduce the strictness behaviour of a function,
or it should be done only with caution.
</para>

</sect3>

<sect3 id="observe-and-root-optimisation">
<title>Interaction with the root optimisation</title>

<para>
The hugs compiler uses an optimisation when generating code that builds
expressions on the heap. If a function definition has the form
<programlisting>
  f arg1 .. argN = ..... f arg1 .. argM .....
</programlisting>
where 1 &le; <replaceable>M</replaceable> &le; <replaceable>N</replaceable>,
then the expression graph for <replaceable>f arg1 .. argM</replaceable>
is copied rather than rebuilt from individual application nodes.
This interacts with the observation algorithm so that observing functions
of the above form give unexpected results.
</para>

<para>
For instance consider the expression
<screen>
  observe "fold" foldl (+) 0 [1..3]
</screen>
When the root optimisation is applied to the compilation
of <literal>foldl</literal>, we see
<screen>
  fold
    { \ primPlusInteger 6 []  -> 6
    , \ { \ 3 3  -> 6
	} 3 (3 : [])  -> 6
    , \ { \ 1 2  -> 3
	} 1 (2 : 3 : [])  -> 6
    , \ { \ 0 1  -> 1
	} 0 (1 : 2 : 3 : [])  -> 6
</screen>
instead of the expected
<screen>
  fold
    { \ { \ 0 1  -> 1
	, \ 1 2  -> 3
	, \ 3 3  -> 6
	} 0 (1 : 2 : 3 : [])  -> 6
    }
</screen>
The first form reports the arguments at each application
of <literal>foldl</literal>,
while the second reports the arguments for just the initial application
(the one marked by <literal>observe</literal>).
</para>

<para>
The root optimisation can be disabled using the
<link linkend=option-root-optimisation><option>-R</option></link> option.
This can be done from the command line or by using
<command>:s</command> <option>-R</option> at the Hugs prompt.
If you want to compile the prelude definitions without the root optimisation
you must invoke Hugs with the <option>-R</option> option.
</para>

<para>
Testing of execution time with and without the root optimisation for a
selection of 23 benchmarks from the nofib suite has been carried out.
All but 5 tests resulted in an execution time penalty of less than 3%
when running without root optimisation (some even showed a very minor
speedup).
</para>

</sect3>

<sect3>
<title>Known problems</title>

<para>
Hugs can produce infinite (cyclic) dictionaries when implementing overloading.
The observation reporting mechanism does not detect these at present, which
leads to a non-terminating report. We plan to address this in a future
release.
</para>

</sect3>

</sect2>

<sect2>
<title>Reporting HugsHood bugs</title>

<para>
Please report bugs to Richard Watson, <email>rwatson@usq.edu.au</email>
</para>

<para>
In particular, if the message
<screen>
  Warning: observation sanity counter > 0
</screen>
appears, and your program has not terminated abnormally, please report
the error situation.
</para>

</sect2>

</sect1>

</chapter>
