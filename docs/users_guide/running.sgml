<chapter id="running">
<title>Running Hugs</title>

<sect1 id="passing-options">
<title>Passing options to Hugs</title>

<cmdsynopsis>
<command>hugs</command>
<arg rep=repeat choice=opt><replaceable>option</replaceable></arg>
<arg rep=repeat choice=opt><replaceable>file</replaceable></arg>
</cmdsynopsis>

<para>
The behaviour of Hugs may be modified by options.
These are initially set to default values,
and then read from the following sources in order:
<orderedlist>
<listitem>
<para>
(Windows only) the registry under the <literal>HKEY_LOCAL_MACHINE</literal> key.
</para>
</listitem>

<listitem>
<para>
(Windows only) the registry under the <literal>HKEY_CURRENT_USER</literal> key.
This step is skipped if the environment variable
<literal>IGNORE_USER_REGISTRY</literal> is set,
providing an emergency workaround if the settings are invalid.
</para>
</listitem>

<listitem>
<para>
(Hugs for Windows only)
the GUI settings.
</para>
</listitem>

<listitem>
<para>
The environment variable <literal>HUGSFLAGS</literal>, if set.
</para>
</listitem>

<listitem>
<para>
The Hugs command line.
</para>
</listitem>

</orderedlist>
</para>

<para>
See <ulink url="http://cvs.haskell.org/Hugs/pages/hugsman/started.html">Section 4 of the <citetitle pubwork=article>Hugs 98 User Manual</citetitle></ulink>.
</para>

</sect1>

<sect1 id="options-list">
<title>Hugs options</title>

<para>
Hugs takes two kinds of options:
<itemizedlist>
<listitem>
<para>
Toggles like <option>+t</option> or <option>-t</option>,
which start with <literal>+</literal> or <literal>-</literal>
to turn them on  or  off,  respectively.
</para>
</listitem>

<listitem>
<para>
Options that set a parameter value, like
<option>-P</option><replaceable>str</replaceable>,
in which <literal>-</literal> could be replaced by <literal>+</literal>,
the choice making no difference.
</para>
</listitem>
</itemizedlist>
</para>

<sect2 id="options-language">
<title>Language options</title>

<variablelist>

<varlistentry id="option-98">
<term><option>+98</option></term>
<listitem>
<para>
Accept only Haskell 98.
This is on by default, and cannot be changed within Hugs.
Turning this off enables several special Hugs extensions,
which are described in <xref linkend="hugs-ghc">, <xref linkend="hugs-only">
and the <citetitle pubwork=article>Hugs 98 User Manual</citetitle>.
</para>
</listitem>
</varlistentry>

<varlistentry id="option-overlapping">
<term><option>+o</option></term>
<listitem>
<para>
Allow overlapping instances (a Hugs extension; default: off)
</para>
</listitem>
</varlistentry>

<varlistentry id="option-unsafe-overlapping">
<term><option>+O</option></term>
<listitem>
<para>
Allow unsafe overlapping instances (a Hugs extension; default: off)
</para>
</listitem>
</varlistentry>

<varlistentry id="option-here-documents">
<term><option>+H</option></term>
<listitem>
<para>
Support <emphasis>here documents</emphasis>
(named after similar things in Unix shells),
another way of writing large string literals
(see <xref linkend="here-documents">).
This extension is turned off by default.
</para>
</listitem>
</varlistentry>

<varlistentry id="option-with-dlet">
<term><option>+W</option></term>
<listitem>
<para>
Use old implicit parameter syntax
(a Hugs extension; default: off)
</para>
<para>
With the <option>-98</option> option, Hugs supports implicit parameters
(see <xref linkend="implicit-parameters">).
If the <option>+W</option> option is also given,
Hugs accepts the obsolete syntax for bindings using additional keywords
<literal>dlet</literal> and <literal>with</literal>.
Note that this will cause some libraries to fail,
e.g. <literal>Foreign</literal>.
This option will disappear in time.
</para>
</listitem>
</varlistentry>

</variablelist>
</sect2>

<sect2 id="options-loading">
<title>Module loading</title>

<variablelist>

<varlistentry id="option-literate">
<term><option>+l</option></term>
<listitem>
<para>
Literate scripts as default (default: off)
</para>
</listitem>
</varlistentry>

<varlistentry id="option-literate-errors">
<term><option>+e</option></term>
<listitem>
<para>
Warn about errors in literate scripts (default: on)
</para>
</listitem>
</varlistentry>

<varlistentry id="option-dots">
<term><option>+.</option></term>
<listitem>
<para>
Print dots to show progress while loading modules (default: off)
</para>
</listitem>
</varlistentry>

<varlistentry id="option-quiet">
<term><option>+q</option></term>
<listitem>
<para>
Print nothing to show progress while loading modules (default: off)
</para>
</listitem>
</varlistentry>

<varlistentry id="option-show-loaded">
<term><option>+w</option></term>
<listitem>
<para>
Always show which files were loaded (default: on)
</para>
</listitem>
</varlistentry>

<varlistentry id="option-preprocessor">
<term><option>-F</option><replaceable>cmd</replaceable></term>
<listitem>
<para>
Preprocess source files before loading.
</para>
<para>
Instead of reading a source file directly, Hugs will
execute <replaceable>cmd</replaceable> with the source file name as argument,
and read the standard output.
</para>
</listitem>
</varlistentry>

<varlistentry id="option-search-path">
<term><option>-P</option><replaceable>str</replaceable></term>
<listitem>
<para>
Set search path for source files to <replaceable>str</replaceable>,
which should be a list of directories separated by colons
(semicolons on Windows, DOS or Macs).
A null entry in this list will be replaced by the previous search path;
a null <replaceable>str</replaceable> means the default path.
Any occurrences of <literal>{Hugs}</literal> in this string will be replaced
by the Hugs library directory.
The default value is
<programlisting>
{Hugs}/libraries:{Hugs}/oldlib
</programlisting>
</para>
<para>
The interpreter won't let you change the search path if that would
prevent it from reading the <literal>Prelude</literal>.
</para>
</listitem>
</varlistentry>

<varlistentry id="option-suffixes">
<term><option>-S</option><replaceable>str</replaceable></term>
<listitem>
<para>
Set list of filename suffixes.
</para>
<para>
Normally, when you import a module <replaceable>M</replaceable>,
Hugs looks for files <replaceable>M</replaceable><literal>.hs</literal>
and <replaceable>M</replaceable><literal>.lhs</literal>
in each directory in you search path.
With this option, you can change this list,
in a similar way to the <option>-P</option> option for the search path.
By default, the suffix list is <quote><literal>.hs:.lhs</literal></quote>,
which gives the behaviour just described.
(NB: the <quote><literal>:</literal></quote> is the Unix separator.
Windows or Macs use <quote><literal>;</literal></quote> instead.)
If you use <literal>-S:.xhs</literal> then the suffix
list becomes <quote><literal>.hs:.lhs:.xhs</literal></quote>,
so Hugs will look for
<replaceable>M</replaceable><literal>.hs</literal>,
<replaceable>M</replaceable><literal>.lhs</literal>
and <replaceable>M</replaceable><literal>.xhs</literal>.
</para>
<para>
A null entry in this list will be replaced by the previous suffix list;
a null <replaceable>str</replaceable> means the default list.
</para>
<para>
The interpreter won't let you change the suffix list if that would
prevent it from reading the <literal>Prelude</literal>,
i.e. you must include <quote><literal>.hs</literal></quote>.
Note also that the interpreter knows that files ending in
<quote><literal>.lhs</literal></quote> are literate scripts;
no other suffix is treated that way.
</para>
<para>
This option can be useful in conjunction with the preprocessor option
(<option>-F</option>).
The preprocessor can examine the filename to decide what to do with the file.
</para>
</listitem>
</varlistentry>

</variablelist>
</sect2>

<sect2 id="options-editor">
<title>Source file editor</title>

<variablelist>

<varlistentry id="option-editor">
<term><option>-E</option><replaceable>str</replaceable></term>
<listitem>
<para>
Specify the editor used by the <literal>:edit</literal> command
(see <xref linkend="module-commands">).
For example, to have Hugs invoke <literal>vi</literal> to edit your files,
use
<programlisting>
  -Evi
</programlisting>
The argument string is actually a template string that gets expanded
by Hugs, via the following rules:
<itemizedlist>

<listitem>
<para>
all occurrences of <literal>%d</literal> are replaced by the line number
of where the last error occurred (if any).
Please consult your editor's documentation for ways of specifying the
line number.
</para>
</listitem>

<listitem>
<para>
all occurrences of <literal>%s</literal> are replaced by the name of the file.
If an occurrence of <literal>%s</literal> is both preceded by and followed
by space, the filename is enclosed in double-quotes.
</para>
</listitem>

<listitem>
<para>
all occurrences of <literal>%f</literal> are replaced by the absolute filename
(provided your platform lets you find the absolute path to a file.)
Most of the time, <literal>%s</literal> will be just fine, but in case your
editor doesn't handle relative filenames correctly, try
using <literal>%f</literal>.
</para>
</listitem>

<listitem>
<para>
all occurrences of <literal>%%</literal> are replaced by <literal>%</literal>.
</para>
</listitem>

<listitem>
<para>
(win32 only): if the <option>-E</option> string is prefixed with
the character <quote><literal>&amp;</literal></quote>,
then the invocation is asynchronous, that is, the editor process
is created, but Hugs won't wait for the editor to terminate.
</para>
</listitem>

<listitem>
<para>
(win32 only): if the <option>-E</option> string is prefixed with
the character <quote><literal>!</literal></quote>,
then the invocation will be asynchronous and use the underlying
command processor/shell to execute the command.
</para>
</listitem>

</itemizedlist>
<para>
If neither <literal>%s</literal> nor <literal>%f</literal> occurs within
the <option>-E</option> string,
then the filename is appended before invoking the editor.
</para>

<para>
Here are some example editor configurations:
</para>

<itemizedlist>
<listitem>
<para>
TextPad
<programlisting>
  -E"c:/Program Files/TextPad 4/textpad \"%s\"(%d)"
</programlisting>
</para>
</listitem>
       
<listitem>
<para>
vi and clones
<programlisting>
  -E"vi +%d %s"
</programlisting>
</para>
</listitem>

<listitem>
<para>
gnuclient (for use with (X)Emacs)
<programlisting>
  -E"gnuclient +%d %s"
</programlisting>
</para>
</listitem>
</itemizedlist>

</listitem>
</varlistentry>

</variablelist>
</sect2>

<sect2 id="options-evaluation">
<title>Expression evaluation and printing</title>

<variablelist>

<varlistentry id="option-heap-size">
<term><option>-h</option><replaceable>num</replaceable></term>
<listitem>
<para>
Set heap size (cannot be changed within Hugs; default: 250K)
</para>

<varlistentry id="option-prompt">
<term><option>-p</option><replaceable>str</replaceable></term>
<listitem>
<para>
Set prompt string to <replaceable>str</replaceable>
(default: <quote><literal>%s> </literal></quote>).
Any <literal>%s</literal> in <replaceable>str</replaceable>
will be replaced by the current module name.
</para>

<varlistentry id="option-repeat-string">
<term><option>-r</option><replaceable>str</replaceable></term>
<listitem>
<para>
Set repeat last expression string to <replaceable>str</replaceable>
(default: <quote><literal>$$</literal></quote>).
</para>

<varlistentry id="option-constraint-cutoff">
<term><option>-c</option><replaceable>num</replaceable></term>
<listitem>
<para>
Set constraint cutoff limit in the type checker to
<replaceable>num</replaceable> (default: 40).
</para>

<varlistentry id="option-print-reductions">
<term><option>+s</option></term>
<listitem>
<para>
Print number of reductions/cells after each evaluation (default: off)
</para>
</listitem>
</varlistentry>

<varlistentry id="option-print-type">
<term><option>+t</option></term>
<listitem>
<para>
Print type after each evaluation (default: off)
</para>
</listitem>
</varlistentry>

<varlistentry id="option-full-kind-errors">
<term><option>+k</option></term>
<listitem>
<para>
Show kind errors in full (default: off)
</para>
</listitem>
</varlistentry>

<varlistentry id="option-use-show">
<term><option>+u</option></term>
<listitem>
<para>
Use <literal>show</literal> to display results (default: on)
</para>

<para>
By default, the values of expressions typed at the prompt are printed using
the <literal>show</literal> member of the <literal>Show</literal> class:
<screen>
  Prelude> [Just (2+3), Nothing]
  [Just 5,Nothing]
</screen>
You can define this function as desired for any new datatype.
If the type of the expression is not an instance of the
<literal>Show</literal> class, an error results:
<screen>
  Prelude> id
  ERROR - Cannot find "show" function for:
  *** Expression : id
  *** Of type    : a -> a
</screen>
With the <option>-u</option> option, a built-in printer is used instead,
and this works for any type:
<screen>
  Prelude> :set -u
  Prelude> id
  id
  Prelude> \x -> x
  v1497
  Prelude> [Just (2+3), Nothing]
  [Maybe_Just 5,Maybe_Nothing]
</screen>
Another advantage of the built-in printer is its treatment of failures,
or exceptions.
Normally, an exception causes immediate failure of the expression:
<screen>
  Prelude> :set +u
  Prelude> 1 + 2/0

  Program error: divide by zero

  Prelude> [1, 2 + error "foo", 3]
  [1,
  Program error: foo
</screen>
However the built-in printer prints the whole value, with embedded exceptions:
<screen>
  Prelude> :set -u
  Prelude> [1, 2 + error "foo", 3]
  [1,{error "foo"},3]
</screen>
Sometimes a component could produce one of two or more exceptions,
but the built-in printer shows only one of them:
<screen>
  Prelude> 1 + error "foo" + error "bar"
  {error "foo"}
</screen>
</para>
</listitem>
</varlistentry>

<varlistentry id="option-print-gc">
<term><option>+g</option></term>
<listitem>
<para>
Print number of cells recovered after each garbage collection (default: off)
</para>
</listitem>
</varlistentry>

<varlistentry id="option-qualify-names">
<term><option>+Q</option></term>
<listitem>
<para>
Qualify names when printing (default: off)
</para>
<para>
By default, the interpreter will print out names without qualifying
them with their defining modules.
Most of the time that's exactly what you want,
but can become confusing if you re-define types and functions;
the error messages not pinning down what entity it is referring to.
To have the interpreter qualify the names, use <option>+Q</option>.
Typically, you use <option>+Q</option> when resolving errors,
but turn it back off again afterwards.
</para>
</listitem>
</varlistentry>

<varlistentry id="option-display-io">
<term><option>+I</option></term>
<listitem>
<para>
Display results of IO programs (default: off)
</para>
<para>
By default, an expression of <literal>IO</literal> type typed at the prompt
is executed for effect, but the final value it produces is discarded.
When <option>+I</option> is used, such an expression is evaluated,
and then its result is printed with <literal>Prelude.print</literal>:
<screen>
  Prelude> :set +I
  Prelude> (return 'a' :: IO Char)
  'a'
  Prelude>
</screen>
i.e., evaluating an IO action <replaceable>m</replaceable>
with <option>+I</option> in effect is equivalent to evaluating
<quote><literal>do { x <- m ; print x }</literal></quote>
with <option>-I</option>.
</para>
</listitem>
</varlistentry>

<varlistentry id="option-default-types">
<term><option>+T</option></term>
<listitem>
<para>
Defaulting types when printing (default: off)
</para>
<para>
When printing out types, the interpreter will not try to
simplify types by applying Haskell's defaulting rules for
numeric types, e.g.,
<screen>
  Prelude> :t 1
  1 :: Num a => a
  Prelude>
</screen>
With the <option>+T</option> option,
the interpreter attempts to <quote>default</quote> types first:
<screen>
  Prelude> :set +T
  Prelude> :t 1
  1 :: Integer
  Prelude>
</screen>
Default: -T
</para>
</listitem>
</varlistentry>

<varlistentry id="option-root-optimisation">
<term><option>+R</option></term>
<listitem>
<para>
Enable root optimisation (default: on)
</para>

<para>
You might want to turn this off if you're using the observation-based
debugger (see <xref linkend="observe-and-root-optimisation">).
</listitem>
</varlistentry>

</variablelist>
</sect2>

</sect1>

<sect1 id="runhugs">
<title>Standalone programs</title>

<cmdsynopsis>
<command>runhugs</command>
<arg rep=repeat choice=opt><replaceable>option</replaceable></arg>
<arg choice=plain><replaceable>file</replaceable></arg>
</cmdsynopsis>

<para>
The <command>runhugs</command> command is an interpreter for an executable Hugs
script, which must be a literate script containing a Haskell
<literal>Main</literal> module.
For example, an executable file might contain the lines
<programlisting> 
  #!/usr/local/bin/runhugs

  > module Main where
  > main = putStr "Hello, World\n"
</programlisting> 
When this file is executed, <command>runhugs</command> will invoke
the <literal>main</literal> function.
Any arguments given on the command line will be available through
the <literal>getArgs</literal> action.
</para>

</sect1>

<sect1 id="ffihugs">
<title>Compiling modules that use the Foreign Function Interface</title>

<cmdsynopsis>
<command>ffihugs</command> <arg><option>+G</option></arg>
<arg rep=repeat choice=opt><replaceable>option</replaceable></arg>
<arg rep=repeat choice=opt><option>+L</option><replaceable>cc-option</replaceable></arg>
<arg choice=plain><replaceable>file</replaceable></arg>
</cmdsynopsis>

<para>
Suppose you have some C functions in <literal>test.c</literal>
and some ffi declarations for those functions in <literal>Test.hs</literal>
and the code in <literal>test.c</literal> needs to be
compiled with <option>-lm</option>.
To use these with Hugs, you must first use <command>ffihugs</command>
to generate <literal>Test.c</literal>, compile it and link it against
<literal>test.c</literal> with <option>-lm</option> to produce
<literal>Test.so</literal>:
<programlisting>
  ffihugs +G +L"test.c" +L"-lm" Test.hs 
</programlisting>
(If <literal>Test.hs</literal> depends on other ffi modules,
you'll have to compile them first.)
Now you can run Hugs as normal;
when <literal>Test.hs</literal> is loaded,
Hugs will load <literal>Test.so</literal>.)
<programlisting>
  hugs Test.hs
</programlisting>
and then use the imported or exported functions.

</sect1>

</chapter>
