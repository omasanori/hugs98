<chapter id="hugs-ghc">
<title>Language extensions supported by Hugs and GHC</title>

<para>These experimental features are enabled with the <option>-98</option>
option.
Most are described in
<ulink url="http://cvs.haskell.org/Hugs/pages/hugsman/exts.html">Section 7 of the <citetitle pubwork=article>Hugs 98 User Manual</citetitle></ulink>.
Those described in this chapter are also supported by
<ulink url="http://www.haskell.org/ghc/">GHC</ulink>
with appropriate options,
though in some cases the GHC versions are more general
</para>

<sect1 id="syntax-extensions">
<title>Syntactic extensions</title>

<sect2 id="recursive-do">
<title>Recursive do-notation</title>

<para>
The recursive do-notation (also known as mdo-notation) is implemented
as described in:

    <citetitle pubwork=article>A recursive do for Haskell</citetitle>,
    Levent Erk&ouml;k and John Launchbury,
    <citetitle pubwork=book>Haskell Workshop 2002</citetitle>,
    pages: 29&ndash;37. Pittsburgh, Pennsylvania.
</para>

<para>
The do-notation of Haskell does not allow recursive bindings, that is,
the variables bound in a do-expression are visible only in the textually
following code block. Compare this to a let-expression, where bound
variables are visible in the entire binding group. It turns out that
several applications can benefit from recursive bindings in the do-notation,
and this extension provides the necessary syntactic support.
</para>

<para>
Here is a simple (yet contrived) example:
<programlisting>
  import Control.Monad.Fix

  justOnes = mdo xs <- Just (1:xs)
                 return xs
</programlisting>
As you can guess <literal>justOnes</literal> will evaluate to
<literal>Just [1,1,1,...</literal>
</para>

<para>
The <literal>Control.Monad.Fix</literal> module introduces
the <literal>MonadFix</literal> class, defined as
<programlisting>
  class Monad m => MonadFix m where
      mfix :: (a -> m a) -> m a
</programlisting>
The function <literal>mfix</literal> dictates how the required recursion
operation should be performed.
If recursive bindings are required for a monad, then that
monad must be declared an instance of the <literal>MonadFix</literal> class.
For details, see the above mentioned reference.
</para>

<para>
The <literal>Control.Monad.Fix</literal> module also defines instances of
<literal>MonadFix</literal> for <literal>List</literal>,
<literal>Maybe</literal> and <literal>IO</literal>.
Furthermore, several other monad modules provide instances of the
<literal>MonadFix</literal> class, including
the <literal>Control.Monad.ST</literal> and
<literal>Control.Monad.ST.Lazy</literal>
modules for Haskell's internal state monad (strict and lazy, respectively).
</para>

<para>
There are three important points in using the recursive-do notation:
<itemizedlist>
<listitem><para>
The recursive version of the do-notation uses
the keyword <literal>mdo</literal> (rather than <literal>do</literal>).
</para></listitem>

<listitem><para>
You should <quote><literal>import Control.Monad.Fix</literal></quote>.
</para></listitem>

<listitem><para>
Hugs should be started with the flag <option>-98</option>.
</para></listitem>
</itemizedlist>
The web page: <quote><ulink url="http://www.cse.ogi.edu/PacSoft/projects/rmb">http://www.cse.ogi.edu/PacSoft/projects/rmb</ulink></quote>
contains up to date information on recursive monadic bindings.
</para>

<para>
Historical note: The old implementation of the mdo-notation (and most
of the existing documents) used the name <literal>MonadRec</literal>
for the class and the corresponding library.
</para>

</sect2>

<sect2 id="zip-comprehension">
<title>Parallel list comprehensions (a.k.a. zip-comprehensions)</title>

<para>
Parallel list comprehensions are a natural extension to list comprehensions.
List comprehensions can be thought of as a nice syntax for writing maps and
filters.
Parallel comprehensions extend this to include the <literal>zipWith</literal>
family.
</para>

<para>
A parallel list comprehension has multiple independent branches of qualifier
lists, each separated by a <quote><literal>|</literal></quote> symbol.
For example, the following zips together two lists:
<programlisting>
   [ (x, y) | x <- xs | y <- ys ]
</programlisting>
The behavior of parallel list comprehensions follows that
of <literal>zip</literal>, in that
the resulting list will have the same length as the shortest branch.
</para>

<para>
We can define parallel list comprehensions by translation to regular
comprehensions.
Given a parallel comprehension of the form:
<programlisting>
   [ e | p1 <- e11, p2 <- e12, ...
       | q1 <- e21, q2 <- e22, ...
       ...
   ]
</programlisting>
This will be translated to:
<programlisting>
   [ e | ((p1,p2), (q1,q2), ...) <- zipN [(p1,p2) | p1 <- e11, p2 <- e12, ...]
                                         [(q1,q2) | q1 <- e21, q2 <- e22, ...]
                                         ...
   ]
</programlisting>
where <quote><replaceable>zipN</replaceable></quote>
is the appropriate zip for the given number of branches.
</para>

</sect2>

</sect1>

<sect1 id="class-extensions">
<title>Type class extensions</title>

<sect2 id="flexible-contexts">
<title>More flexible contexts</title>

<para>to be written</para>

</sect2>

<sect2 id="flexible-instances">
<title>More flexible instance declarations</title>

<para>to be written</para>

</sect2>

<sect2 id="overlapping-instances">
<title>Overlapping instances</title>

<para>
These are enabled in Hugs with the
<link linkend="option-overlapping"><option>+o</option></link> option.
</para>

</sect2>

<sect2 id="multi-param">
<title>Multiple parameter type classes</title>

<para>
In Haskell 98, type classes have a single parameter;
they may be thought of as sets of types.
In Hugs, they may have one or more parameters,
corresponding to relations between types, e.g.
<programlisting>
  class Isomorphic a b where
    from :: a -> b
    to :: b -> a
</programlisting>
</para>

</sect2>

<sect2 id="functional-dependencies">
<title>Functional dependencies</title>

<para>
Multiple parameter type classes often lead to ambiguity.
Functional dependencies (inspired by relational databases)
provide a partial solution,
and were introduced in
<citetitle pubwork=article>Type Classes with Functional Dependencies</citetitle>,
Mark P. Jones, In
<citetitle pubwork=book>Proceedings of the 9th European Symposium on Programming</citetitle>, LNCS vol. 1782, Springer 2000.
</para>

<para>
Functional dependencies are introduced by a vertical bar:
<programlisting>
  class MyClass a b c | a -> b where
</programlisting>
This says that the <literal>b</literal> parameter is determined by the
<literal>a</literal> parameter;
there cannot be two instances of <literal>MyClass</literal> with the same
first parameter and different second parameters.
The type inference system then uses this information to resolve many
ambiguities.
You can have several dependencies:
<programlisting>
  class MyClass a b c | a -> b, a -> c where
</programlisting>
This example could also be written
<programlisting>
  class MyClass a b c | a -> b c where
</programlisting>
Similarly more than one type parameter may appear to the left of the arrow:
<programlisting>
  class MyClass a b c | a b -> c where
</programlisting>
This says that the <literal>c</literal> parameter is determined by the
<literal>a</literal> and <literal>b</literal> parameters together;
there cannot be two instances of <literal>MyClass</literal> with the same
first parameter and second parameters, but different third parameters.
</para>

</sect2>

</sect1>

<sect1 id="quantified-types">
<title>Quantified types</title>

<sect2 id="rank-2-types">
<title>Rank 2 types</title>

<para>to be written
(GHC supports arbitrary rank polymorphism.)
</para>

</sect2>

<sect2 id="polymorphic-components">
<title>Polymorphic components</title>

<para>to be written</para>

</sect2>

<sect2 id="existential-quantification">
<title>Existential quantification</title>

<para>to be written</para>

</sect2>

</sect1>

<sect1 id="type-annotations">
<title>Type annotations in patterns</title>

<para>to be written</para>

</sect1>

<sect1 id="implicit-parameters">
<title>Implicit parameters</title>

<para> Implicit parameters are implemented as described in
<citetitle pubwork=article>Implicit parameters: dynamic scoping with static types</citetitle>,
J Lewis, MB Shields, E Meijer, J Launchbury,
<citetitle pubwork=book>27th ACM Symposium on Principles of Programming Languages (POPL'00)</citetitle>,
Boston, Jan 2000.
Note however that the binding syntax in that paper,
using keywords <literal>dlet</literal> and <literal>with</literal>,
has been replaced by the form presented below.
</para>

<para>(Most of the following, still rather incomplete,
documentation is due to Jeff Lewis.)</para>

<para>
A variable is called <emphasis>dynamically bound</emphasis> when it is
bound by the calling context of a function and
<emphasis>statically bound</emphasis> when bound by the callee's context.
In Haskell, all variables are statically bound.
Dynamic binding of variables is a notion that goes back to Lisp,
but was later discarded in more modern incarnations, such as Scheme,
as dynamic binding can be very confusing in an untyped language.
Unfortunately typed languages,
in particular Hindley-Milner typed languages like Haskell,
only support static scoping of variables.
</para>

<para>
However, by a simple extension to the type class system of Haskell,
we can support dynamic binding.
Basically, we express the use of a dynamically bound variable
as a constraint on the type.
These constraints lead to types of the form <literal>(?x::t') => t</literal>,
which says
<quote>this function uses a dynamically-bound variable <literal>?x</literal>
of type <literal>t'</literal></quote>.
For example,
the following expresses the type of a <literal>sort</literal> function,
implicitly parameterized by a comparison function named <literal>cmp</literal>.
<programlisting>
  sort :: (?cmp :: a -> a -> Bool) => [a] -> [a]
</programlisting>
The dynamic binding constraints are just a new form of predicate
in the type class system.
</para>

<para>
An implicit parameter occurs in an expression using the special form
<literal>?x</literal>,
where <literal>x</literal> is any valid identifier
(e.g. <literal>ord ?x</literal> is a valid expression).
Use of this construct also introduces a new
dynamic-binding constraint in the type of the expression.
For example, the following definition
shows how we can define an implicitly parameterized sort function in
terms of an explicitly parameterized <literal>sortBy</literal> function:
<programlisting>
  sortBy :: (a -> a -> Bool) -> [a] -> [a]

  sort   :: (?cmp :: a -> a -> Bool) => [a] -> [a]
  sort    = sortBy ?cmp
</programlisting>
</para>

<sect2>
<title>Implicit-parameter type constraints</title>

<para>
Dynamic binding constraints behave just like other type class
constraints in that they are automatically propagated.
Thus, when a function is used,
its implicit parameters are inherited by the function that called it.
For example, our <literal>sort</literal> function might be used
to pick out the least value in a list:
<programlisting>
  least   :: (?cmp :: a -> a -> Bool) => [a] -> a
  least xs = fst (sort xs)
</programlisting>
Without lifting a finger, the <literal>?cmp</literal> parameter is
propagated to become a parameter of <literal>least</literal> as well.
With explicit parameters,
the default is that parameters must always be explicit propagated.
With implicit parameters, the default is to always propagate them.
</para>

<para>
An implicit-parameter type constraint differs from other type class
constraints in the following way:
all uses of a particular implicit parameter must have the same type.
This means that the type of <literal>(?x, ?x)</literal>
is <literal>(?x::a) => (a,a)</literal>, and not
<literal>(?x::a, ?x::b) => (a, b)</literal>, as would be the case for type
class constraints.
</para>

<para>
You can't have an implicit parameter in the context of a class or instance
declaration.  For example, both these declarations are illegal:
<programlisting>
  class (?x::Int) => C a where ...
  instance (?x::a) => Foo [a] where ...
</programlisting>
Reason: exactly which implicit parameter you pick up depends on exactly where
you invoke a function.
But the <quote>invocation</quote> of instance declarations is done behind
the scenes by the compiler,
so it's hard to figure out exactly where it is done.
The easiest thing is to outlaw the offending types.
</para>

<para>
Implicit-parameter constraints do not cause ambiguity.
For example, consider:
<programlisting>
  f :: (?x :: [a]) => Int -> Int
  f n = n + length ?x

  g :: (Read a, Show a) => String -> String
  g s = show (read s)
</programlisting>
Here, <literal>g</literal> has an ambiguous type, and is rejected,
but <literal>f</literal> is fine.
The binding for <literal>?x</literal> at <literal>f</literal>'s call site is
quite unambiguous, and fixes the type <literal>a</literal>.
</para>

</sect2>

<sect2>
<title>Implicit-parameter bindings</title>

<para>
An implicit parameter is <emphasis>bound</emphasis> using the standard
<literal>let</literal> or <literal>where</literal> binding forms.
For example, we define the <literal>min</literal> function by binding
<literal>cmp</literal>:
<programlisting>
  min :: [a] -> a
  min  = let ?cmp = (<=) in least
</programlisting>
</para>

<para>
A group of implicit-parameter bindings may occur anywhere a normal group
of Haskell bindings can occur, except at top level.
That is, they can occur in a <literal>let</literal>
(including in a list comprehension or do-notation),
or a <literal>where</literal> clause.
Note the following points:
<itemizedlist>
<listitem><para>
An implicit-parameter binding group must be a
collection of simple bindings to implicit-style variables
(no function-style bindings, and no type signatures);
these bindings are neither polymorphic or recursive.
</para></listitem>

<listitem><para>
You may not mix implicit-parameter bindings with ordinary bindings in a
single <literal>let</literal> expression;
use two nested <literal>let</literal>s instead.
(In the case of <literal>where</literal> you are stuck,
since you can't nest <literal>where</literal> clauses.)
</para></listitem>

<listitem><para>
You may put multiple implicit-parameter bindings in a single binding group;
but they are <emphasis>not</emphasis> treated as a mutually recursive group
(as ordinary <literal>let</literal> bindings are).
Instead they are treated as a non-recursive group,
simultaneously binding all the implicit parameters.
The bindings are not nested, and may be re-ordered without changing
the meaning of the program.
For example, consider:
<programlisting>
  f t = let { ?x = t; ?y = ?x+(1::Int) } in ?x + ?y
</programlisting>
The use of <literal>?x</literal> in the binding for <literal>?y</literal>
does not <quote>see</quote> the binding for <literal>?x</literal>,
so the type of <literal>f</literal> is
<programlisting>
  f :: (?x::Int) => Int -> Int
</programlisting>
</para></listitem>
</itemizedlist>
</para>

</sect2>

</sect1>

</chapter>
